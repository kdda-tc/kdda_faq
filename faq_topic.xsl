<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <!-- Call this stylesheet by passing in the 'navtitle' param, the value of which is found in the publication bookmap (bookmap/chapter/topicref/@navtitle) -->
  
  <!-- The main template -->
  <xsl:template match="*[contains(@class,' topic/concept ')]">
    <xsl:param name="navtitle" />
    <xsl:variable name="topicTitle" select="*[contains(@class,' topic/title ')]"/>
    <div class="section">
      <xsl:attribute name="id">
        <xsl:value-of select="$navtitle"/>
      </xsl:attribute>
      <h2 class="section_header">
        <xsl:value-of select="$topicTitle"/>
      </h2>
      <xsl:variable name="sections" 
                              select="*[contains(@class,' topic/section ')][@outputclass = 'section']"/>
      <xsl:call-template name="processSections">
        <xsl:with-param name="navtitle" select="$navtitle"/>
        <xsl:with-param name="pairs" 
                                       select="$sections"/>
      </xsl:call-template>
    </div>
    <xsl:text disable-output-escaping="yes">&lt;!-- /#</xsl:text>
    <xsl:value-of select="$navtitle"/>
    <xsl:text disable-output-escaping="yes"> --&gt;</xsl:text>
  </xsl:template>

      <!-- For each 'section' elem, write out a <div> that has an incrementing 'id' whose value is in the form "general_01" ++ -->
  <xsl:template name="processSections">
    <xsl:param name="navtitle"/>
    <xsl:param name="pairs"/>
    <xsl:for-each select="$pairs">
      <xsl:variable name="spacer">
        <xsl:choose>
          <xsl:when test="position() &lt; 10">
            <xsl:value-of select="concat($navtitle, '_0', position())"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat($navtitle, '_', position())"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <div class="answer_block">
        <xsl:attribute name="id">
          <xsl:value-of select="$spacer"/>
        </xsl:attribute>
        <xsl:call-template name="pair"/>
      </div>
    </xsl:for-each>
  </xsl:template>

  <!-- Process the Q/A pairs -->
  <xsl:template name="pair">
    <xsl:call-template name="question">
      <xsl:with-param name="q" select="*[contains(@class,' topic/p ')][position() = 1]"/>
    </xsl:call-template>
    <!-- Fill in the answers -->
    <div class="answer">
      <xsl:apply-templates/>
    </div>
  </xsl:template>

  <!-- Make section/p[1] a question heading -->
  <xsl:template name="question">
    <xsl:param name="q"/>
    <h3 class="question">
      <xsl:value-of select="$q"/>
    </h3>
  </xsl:template>

  <!-- Ignore section/p[1] elems when not parsed in 'pair' template -->
  <xsl:template match="*[contains(@class,' topic/section ')]/*[contains(@class,' topic/p ')][position() = 1]"/>

  <!-- Replace 'p' tags -->
  <xsl:template match="*[contains(@class,' topic/p ')]">
    <p>
      <xsl:apply-templates/>
    </p>
  </xsl:template>

  <!-- Replace 'uicontrol' tags -->
  <xsl:template match="*[contains(@class,' topic/ph ui-d/uicontrol ')][@outputclass = 'cmd']">
    <span class="{@outputclass}">
      <xsl:apply-templates/>
    </span>
  </xsl:template>

  <!-- Render all unordered lists -->
  <xsl:template match="*[contains(@class,' topic/ul ')]">
    <ul>
      <xsl:apply-templates/>
    </ul>
  </xsl:template>

  <!-- Render 'li' elems without autogenerated 'p' elems in content -->
  <xsl:template match="*[contains(@class,' topic/li ')]/*[contains(@class,' topic/p ')]">
    <li>
      <xsl:apply-templates/>
    </li>
  </xsl:template>

  <!-- Render 'i' elems -->
  <xsl:template match="*[contains(@class,' hi-d/i ')]">
    <em>
      <xsl:value-of select="."/>
    </em>
  </xsl:template>

  <!-- Render 'b' elems -->
  <xsl:template match="*[contains(@class,' hi-d/b ')]">
    <strong>
      <xsl:value-of select="."/>
    </strong>
  </xsl:template>

</xsl:stylesheet>